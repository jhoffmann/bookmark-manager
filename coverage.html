
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>cmd: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/jhoffmann/bookmark-manager/cmd/add.go (0.0%)</option>
				
				<option value="file1">github.com/jhoffmann/bookmark-manager/cmd/export.go (0.0%)</option>
				
				<option value="file2">github.com/jhoffmann/bookmark-manager/cmd/list.go (0.0%)</option>
				
				<option value="file3">github.com/jhoffmann/bookmark-manager/internal/app/app.go (72.0%)</option>
				
				<option value="file4">github.com/jhoffmann/bookmark-manager/internal/bookmark/bookmark.go (80.6%)</option>
				
				<option value="file5">github.com/jhoffmann/bookmark-manager/internal/config/config.go (69.7%)</option>
				
				<option value="file6">github.com/jhoffmann/bookmark-manager/internal/database/database.go (79.3%)</option>
				
				<option value="file7">github.com/jhoffmann/bookmark-manager/internal/tui/confirm/confirm.go (0.0%)</option>
				
				<option value="file8">github.com/jhoffmann/bookmark-manager/internal/tui/list/model.go (0.0%)</option>
				
				<option value="file9">github.com/jhoffmann/bookmark-manager/internal/tui/styles/styles.go (0.0%)</option>
				
				<option value="file10">github.com/jhoffmann/bookmark-manager/main.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package cmd

import (
        "fmt"
        "os"
        "path/filepath"

        "github.com/jhoffmann/bookmark-manager/internal/app"
        "github.com/jhoffmann/bookmark-manager/internal/bookmark"
        "github.com/jhoffmann/bookmark-manager/internal/tui/styles"
        "github.com/spf13/cobra"
)

// addCmd represents the add command
var addCmd = &amp;cobra.Command{
        Use:   "add [category]",
        Short: "Add the current directory as a bookmark",
        Long: `Add the current directory as a bookmark with an optional category.
If no category is specified, it defaults to 'default'.

Examples:
  bookmark-manager add
  bookmark-manager add work
  bookmark-manager add personal
  bookmark-manager add "my-project"`,
        Args: cobra.MaximumNArgs(1),
        Run:  runAdd,
}

func runAdd(cmd *cobra.Command, args []string) <span class="cov0" title="0">{
        // Initialize app (loads config, database, and service)
        appInstance := app.InitializeOrExit()
        defer appInstance.Close()

        // Get current working directory
        currentDir, err := os.Getwd()
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("%s Failed to get current directory: %v\n",
                        styles.ErrorMessage.Render("✗"), err)
                os.Exit(1)
        }</span>

        // Get absolute path to ensure consistency
        <span class="cov0" title="0">absPath, err := filepath.Abs(currentDir)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("%s Failed to get absolute path: %v\n",
                        styles.ErrorMessage.Render("✗"), err)
                os.Exit(1)
        }</span>

        // Determine category
        <span class="cov0" title="0">category := bookmark.DefaultCategory
        if len(args) &gt; 0 &amp;&amp; args[0] != "" </span><span class="cov0" title="0">{
                category = bookmark.CategoryType(args[0])
        }</span>

        // Check if bookmark already exists
        <span class="cov0" title="0">existingBookmarks, err := bookmark.SearchByFolder(appInstance.Service, absPath)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("%s Failed to check for existing bookmarks: %v\n",
                        styles.ErrorMessage.Render("✗"), err)
                os.Exit(1)
        }</span>

        // Check for exact match
        <span class="cov0" title="0">for _, existing := range existingBookmarks </span><span class="cov0" title="0">{
                if existing.Folder == absPath </span><span class="cov0" title="0">{
                        fmt.Printf("%s Bookmark already exists: %s [%s]\n",
                                styles.WarningMessage.Render("!"),
                                existing.Folder,
                                existing.Category)
                        return
                }</span>
        }

        // Create new bookmark
        <span class="cov0" title="0">newBookmark := &amp;bookmark.Bookmark{
                Folder:   absPath,
                Category: category,
        }

        // Save bookmark
        if err := newBookmark.Save(appInstance.Service); err != nil </span><span class="cov0" title="0">{
                fmt.Printf("%s Failed to save bookmark: %v\n",
                        styles.ErrorMessage.Render("✗"), err)
                os.Exit(1)
        }</span>

        // Success message
        <span class="cov0" title="0">fmt.Printf("%s Added bookmark: %s [%s]\n",
                styles.SuccessMessage.Render("✓"),
                absPath,
                category)</span>
}

// GetAddCmd returns the add command
func GetAddCmd() *cobra.Command <span class="cov0" title="0">{
        return addCmd
}</span>

func init() {<span class="cov8" title="1">
        // Add flags if needed in the future
        // addCmd.Flags().BoolVarP(&amp;force, "force", "f", false, "Force add even if bookmark exists")
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">package cmd

import (
        "encoding/json"
        "fmt"
        "os"
        "strings"

        "github.com/jhoffmann/bookmark-manager/internal/app"
        "github.com/jhoffmann/bookmark-manager/internal/bookmark"
        "github.com/jhoffmann/bookmark-manager/internal/tui/styles"
        "github.com/spf13/cobra"
)

// exportCmd represents the export command
var exportCmd = &amp;cobra.Command{
        Use:   "export [category] [filter]",
        Short: "Export bookmarks to JSON",
        Long: `Export bookmarks to JSON format. Output is written to stdout for piping.

Examples:
  bookmark-manager export &gt; all-bookmarks.json
  bookmark-manager export work &gt; work-bookmarks.json
  bookmark-manager export personal home &gt; personal-home-bookmarks.json
  bookmark-manager export "" projects &gt; project-bookmarks.json`,
        Args: cobra.MaximumNArgs(2),
        Run:  runExport,
}

// ExportBookmark represents the JSON structure for exported bookmarks
type ExportBookmark struct {
        ID          uint   `json:"id"`
        Folder      string `json:"folder"`
        Category    string `json:"category"`
        DateCreated string `json:"date_created"`
}

func runExport(cmd *cobra.Command, args []string) <span class="cov0" title="0">{
        // Initialize app (loads config, database, and service)
        appInstance := app.InitializeOrExit()
        defer appInstance.Close()

        // Parse arguments
        var category bookmark.CategoryType
        var filter string

        if len(args) &gt; 0 &amp;&amp; args[0] != "" </span><span class="cov0" title="0">{
                category = bookmark.CategoryType(args[0])
        }</span>

        <span class="cov0" title="0">if len(args) &gt; 1 </span><span class="cov0" title="0">{
                filter = args[1]
        }</span>

        // Fetch bookmarks based on criteria
        <span class="cov0" title="0">var bookmarks []*bookmark.Bookmark
        var err error

        if category != "" </span><span class="cov0" title="0">{
                // Search by category
                bookmarks, err = bookmark.SearchByCategory(appInstance.Service, category)
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Fprintf(os.Stderr, "%s Failed to search bookmarks by category: %v\n",
                                styles.ErrorMessage.Render("✗"), err)
                        os.Exit(1)
                }</span>
        } else<span class="cov0" title="0"> {
                // Get all bookmarks
                bookmarks, err = bookmark.List(appInstance.Service, 0, 0)
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Fprintf(os.Stderr, "%s Failed to list bookmarks: %v\n",
                                styles.ErrorMessage.Render("✗"), err)
                        os.Exit(1)
                }</span>
        }

        // Apply filter if specified
        <span class="cov0" title="0">if filter != "" </span><span class="cov0" title="0">{
                filteredBookmarks := make([]*bookmark.Bookmark, 0)
                filterLower := strings.ToLower(filter)

                for _, b := range bookmarks </span><span class="cov0" title="0">{
                        if strings.Contains(strings.ToLower(b.Folder), filterLower) ||
                                strings.Contains(strings.ToLower(string(b.Category)), filterLower) </span><span class="cov0" title="0">{
                                filteredBookmarks = append(filteredBookmarks, b)
                        }</span>
                }
                <span class="cov0" title="0">bookmarks = filteredBookmarks</span>
        }

        // Convert to export format
        <span class="cov0" title="0">exportBookmarks := make([]ExportBookmark, len(bookmarks))
        for i, b := range bookmarks </span><span class="cov0" title="0">{
                exportBookmarks[i] = ExportBookmark{
                        ID:          b.ID,
                        Folder:      b.Folder,
                        Category:    string(b.Category),
                        DateCreated: b.DateCreated.Format("2006-01-02T15:04:05Z07:00"),
                }
        }</span>

        // Output JSON to stdout
        <span class="cov0" title="0">encoder := json.NewEncoder(os.Stdout)
        encoder.SetIndent("", "  ") // Pretty print

        if err := encoder.Encode(exportBookmarks); err != nil </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "%s Failed to encode JSON: %v\n",
                        styles.ErrorMessage.Render("✗"), err)
                os.Exit(1)
        }</span>
}

// GetExportCmd returns the export command
func GetExportCmd() *cobra.Command <span class="cov0" title="0">{
        return exportCmd
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">package cmd

import (
        "fmt"
        "os"

        tea "github.com/charmbracelet/bubbletea"
        "github.com/jhoffmann/bookmark-manager/internal/app"
        "github.com/jhoffmann/bookmark-manager/internal/tui/list"
        "github.com/jhoffmann/bookmark-manager/internal/tui/styles"
        "github.com/spf13/cobra"
)

// listCmd represents the list command
var listCmd = &amp;cobra.Command{
        Use:   "list [category] [filter]",
        Short: "Interactive TUI for browsing bookmarks",
        Long: `Launch an interactive TUI to browse, filter, and manage your bookmarks.

Features:
- Tab through categories (All, default, and custom categories)
- Real-time filtering with '/' key
- Delete bookmarks with 'x' key (with confirmation)
- Open folders with 'o' or 'enter' key
- Full keyboard navigation

Examples:
  bookmark-manager list
  bookmark-manager list work
  bookmark-manager list personal home`,
        Args: cobra.MaximumNArgs(2),
        Run:  runList,
}

func runList(cmd *cobra.Command, args []string) <span class="cov0" title="0">{
        // Initialize app (loads config, database, and service)
        appInstance := app.InitializeOrExit()
        defer appInstance.Close()

        // Parse arguments
        var initialCategory string
        var initialFilter string

        if len(args) &gt; 0 &amp;&amp; args[0] != "" </span><span class="cov0" title="0">{
                initialCategory = args[0]
        }</span> else<span class="cov0" title="0"> {
                initialCategory = "All"
        }</span>

        <span class="cov0" title="0">if len(args) &gt; 1 </span><span class="cov0" title="0">{
                initialFilter = args[1]
        }</span>

        // Create TUI model
        <span class="cov0" title="0">model := list.New(appInstance.Service, initialCategory)

        // Set initial filter if provided
        if initialFilter != "" </span>{<span class="cov0" title="0">
                // We'll need to set this after the model is initialized
                // For now, we'll handle this in the model's init
        }</span>

        // Create Bubble Tea program
        <span class="cov0" title="0">program := tea.NewProgram(model, tea.WithAltScreen())

        // Run the program
        finalModel, err := program.Run()
        if err != nil </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "%s TUI error: %v\n",
                        styles.ErrorMessage.Render("✗"), err)
                os.Exit(1)
        }</span>

        // Handle any final state from the model
        <span class="cov0" title="0">if listModel, ok := finalModel.(list.Model); ok </span><span class="cov0" title="0">{
                _ = listModel // We could handle final state here if needed
        }</span>
}

// GetListCmd returns the list command
func GetListCmd() *cobra.Command <span class="cov0" title="0">{
        return listCmd
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">// Package app provides centralized application initialization and setup.
package app

import (
        "fmt"
        "os"

        "github.com/jhoffmann/bookmark-manager/internal/bookmark"
        "github.com/jhoffmann/bookmark-manager/internal/config"
        "github.com/jhoffmann/bookmark-manager/internal/database"
        "github.com/jhoffmann/bookmark-manager/internal/tui/styles"
)

// App holds the database connection and bookmark service
type App struct {
        DB      database.DB
        Service *bookmark.Service
        Config  *config.Config
}

// Close closes the database connection
func (a *App) Close() error <span class="cov8" title="1">{
        return a.DB.Close()
}</span>

// Initialize loads configuration, initializes database, and returns an App instance
// This centralizes all the repetitive setup code from the command files
func Initialize() (*App, error) <span class="cov8" title="1">{
        // Load configuration
        cfg, err := config.Load()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to load configuration: %w", err)
        }</span>

        // Initialize database
        <span class="cov8" title="1">db, err := database.NewDatabase(cfg)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to connect to database: %w", err)
        }</span>

        // Initialize bookmark service
        <span class="cov8" title="1">service := bookmark.NewService(db)

        return &amp;App{
                DB:      db,
                Service: service,
                Config:  cfg,
        }, nil</span>
}

// InitializeOrExit initializes the app and exits on error with styled messages
// This is a convenience function for commands that should exit on initialization failure
func InitializeOrExit() *App <span class="cov0" title="0">{
        app, err := Initialize()
        if err != nil </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "%s %v\n",
                        styles.ErrorMessage.Render("✗"), err)
                os.Exit(1)
        }</span>
        <span class="cov0" title="0">return app</span>
}

// MustInitialize is like Initialize but panics on error (useful for tests)
func MustInitialize() *App <span class="cov8" title="1">{
        app, err := Initialize()
        if err != nil </span><span class="cov8" title="1">{
                panic(fmt.Sprintf("failed to initialize app: %v", err))</span>
        }
        <span class="cov8" title="1">return app</span>
}

// InitializeWithConfig initializes with a specific configuration (useful for testing)
func InitializeWithConfig(cfg *config.Config) (*App, error) <span class="cov8" title="1">{
        // Initialize database
        db, err := database.NewDatabase(cfg)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to connect to database: %w", err)
        }</span>

        // Initialize bookmark service
        <span class="cov8" title="1">service := bookmark.NewService(db)

        return &amp;App{
                DB:      db,
                Service: service,
                Config:  cfg,
        }, nil</span>
}

// InitializeInMemory creates an in-memory database for testing
func InitializeInMemory() (*App, error) <span class="cov8" title="1">{
        cfg := &amp;config.Config{
                DatabasePath: ":memory:",
                LogLevel:     "silent",
        }

        return InitializeWithConfig(cfg)
}</span>
</pre>
		
		<pre class="file" id="file4" style="display: none">// Package bookmark provides functionality for managing folder bookmarks.
// It handles CRUD operations for bookmarks that track folders with categories.
package bookmark

import (
        "fmt"
        "time"

        "github.com/jhoffmann/bookmark-manager/internal/database"
        "gorm.io/gorm"
)

// CategoryType represents the category of a bookmark
type CategoryType string

// DefaultCategory for when one isn't provided
const DefaultCategory CategoryType = "default"

// Bookmark represents a folder bookmark entry
type Bookmark struct {
        ID          uint           `gorm:"primaryKey" json:"id"`
        Folder      string         `gorm:"not null" json:"folder"`
        DateCreated time.Time      `json:"date_created"`
        Category    CategoryType   `gorm:"type:varchar(50);default:'default'" json:"category"`
        CreatedAt   time.Time      `json:"-"`
        UpdatedAt   time.Time      `json:"-"`
        DeletedAt   gorm.DeletedAt `gorm:"index" json:"-"`
}

// Service provides bookmark operations with database access
type Service struct {
        db database.DB
}

// NewService creates a new bookmark service with the provided database
func NewService(db database.DB) *Service <span class="cov8" title="1">{
        return &amp;Service{db: db}
}</span>

// BeforeCreate is a GORM hook that runs before creating a bookmark
func (b *Bookmark) BeforeCreate(tx *gorm.DB) error <span class="cov8" title="1">{
        if b.DateCreated.IsZero() </span><span class="cov8" title="1">{
                b.DateCreated = time.Now()
        }</span>
        <span class="cov8" title="1">if b.Category == "" </span><span class="cov8" title="1">{
                b.Category = DefaultCategory
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// Save saves the bookmark to the database
func (b *Bookmark) Save(service *Service) error <span class="cov8" title="1">{
        if err := b.validate(); err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("validation failed: %w", err)
        }</span>

        <span class="cov8" title="1">gormDB := service.db.GetDB()
        if gormDB == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("database connection is not available")
        }</span>

        <span class="cov8" title="1">if b.ID == 0 </span><span class="cov8" title="1">{
                // Create new bookmark
                if err := gormDB.Create(b).Error; err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to create bookmark: %w", err)
                }</span>
        } else<span class="cov8" title="1"> {
                // Update existing bookmark
                if err := gormDB.Save(b).Error; err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to update bookmark: %w", err)
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// Delete removes the bookmark from the database (soft delete)
func (b *Bookmark) Delete(service *Service) error <span class="cov8" title="1">{
        if b.ID == 0 </span><span class="cov8" title="1">{
                return fmt.Errorf("cannot delete bookmark: ID is required")
        }</span>

        <span class="cov8" title="1">gormDB := service.db.GetDB()
        if gormDB == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("database connection is not available")
        }</span>

        <span class="cov8" title="1">if err := gormDB.Delete(b).Error; err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to delete bookmark: %w", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// SearchByCategory searches for bookmarks by category
func (b *Bookmark) SearchByCategory(service *Service, category CategoryType) ([]*Bookmark, error) <span class="cov8" title="1">{
        return SearchByCategory(service, category)
}</span>

// SearchByCategory searches for bookmarks by category (static method)
func SearchByCategory(service *Service, category CategoryType) ([]*Bookmark, error) <span class="cov8" title="1">{
        gormDB := service.db.GetDB()
        if gormDB == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("database connection is not available")
        }</span>

        <span class="cov8" title="1">var bookmarks []*Bookmark
        if err := gormDB.Where("category = ?", category).Order("date_created DESC").Find(&amp;bookmarks).Error; err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to search bookmarks by category: %w", err)
        }</span>

        <span class="cov8" title="1">return bookmarks, nil</span>
}

// GetByID retrieves a bookmark by its ID
func GetByID(service *Service, id uint) (*Bookmark, error) <span class="cov8" title="1">{
        gormDB := service.db.GetDB()
        if gormDB == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("database connection is not available")
        }</span>

        <span class="cov8" title="1">var bookmark Bookmark
        if err := gormDB.First(&amp;bookmark, id).Error; err != nil </span><span class="cov8" title="1">{
                if err == gorm.ErrRecordNotFound </span><span class="cov8" title="1">{
                        return nil, fmt.Errorf("bookmark with ID %d not found", id)
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to get bookmark: %w", err)</span>
        }

        <span class="cov8" title="1">return &amp;bookmark, nil</span>
}

// List retrieves all bookmarks with optional limit and offset
func List(service *Service, limit, offset int) ([]*Bookmark, error) <span class="cov8" title="1">{
        gormDB := service.db.GetDB()
        if gormDB == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("database connection is not available")
        }</span>

        <span class="cov8" title="1">var bookmarks []*Bookmark
        query := gormDB.Order("date_created DESC")

        if limit &gt; 0 </span><span class="cov8" title="1">{
                query = query.Limit(limit)
        }</span>
        <span class="cov8" title="1">if offset &gt; 0 </span><span class="cov8" title="1">{
                query = query.Offset(offset)
        }</span>

        <span class="cov8" title="1">if err := query.Find(&amp;bookmarks).Error; err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to list bookmarks: %w", err)
        }</span>

        <span class="cov8" title="1">return bookmarks, nil</span>
}

// SearchByFolder searches for bookmarks by folder path (partial match)
func SearchByFolder(service *Service, folderPath string) ([]*Bookmark, error) <span class="cov8" title="1">{
        gormDB := service.db.GetDB()
        if gormDB == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("database connection is not available")
        }</span>

        <span class="cov8" title="1">var bookmarks []*Bookmark
        if err := gormDB.Where("folder LIKE ?", "%"+folderPath+"%").Order("date_created DESC").Find(&amp;bookmarks).Error; err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to search bookmarks by folder: %w", err)
        }</span>

        <span class="cov8" title="1">return bookmarks, nil</span>
}

// validate performs validation on the bookmark fields
func (b *Bookmark) validate() error <span class="cov8" title="1">{
        if b.Folder == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("folder path is required")
        }</span>

        // Set default category if empty
        <span class="cov8" title="1">if b.Category == "" </span><span class="cov8" title="1">{
                b.Category = DefaultCategory
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// String returns a string representation of the bookmark
func (b *Bookmark) String() string <span class="cov8" title="1">{
        return fmt.Sprintf("Bookmark{ID: %d, Folder: %s, Category: %s, DateCreated: %s}",
                b.ID, b.Folder, b.Category, b.DateCreated.Format("2006-01-02 15:04:05"))
}</span>
</pre>
		
		<pre class="file" id="file5" style="display: none">// Package config provides configuration management for the bookmark manager application.
// It handles loading configuration from environment variables and provides cross-platform
// default paths for application data.
package config

import (
        "fmt"
        "os"
        "path/filepath"
        "runtime"
)

// Config holds application configuration options
type Config struct {
        DatabasePath string `envconfig:"BM_DATABASE" json:"database_path"`
        LogLevel     string `envconfig:"BM_LOGLEVEL" json:"log_level"`
}

// Load loads configuration from environment variables with sensible defaults
func Load() (*Config, error) <span class="cov8" title="1">{
        config := &amp;Config{
                LogLevel: "warn", // Default log level
        }

        // Load from environment variables
        if dbPath := os.Getenv("BM_DATABASE"); dbPath != "" </span><span class="cov8" title="1">{
                config.DatabasePath = dbPath
        }</span> else<span class="cov8" title="1"> {
                // Use default path in user's config directory
                defaultPath, err := getDefaultDatabasePath()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to get default database path: %w", err)
                }</span>
                <span class="cov8" title="1">config.DatabasePath = defaultPath</span>
        }

        <span class="cov8" title="1">if logLevel := os.Getenv("BM_LOGLEVEL"); logLevel != "" </span><span class="cov8" title="1">{
                config.LogLevel = logLevel
        }</span>

        <span class="cov8" title="1">return config, nil</span>
}

// getDefaultDatabasePath returns the default database path for the current platform
// Linux/Unix: ~/.config/bookmark-manager/bookmarks.db
// macOS: ~/Library/Application Support/bookmark-manager/bookmarks.db
// Windows: %APPDATA%/bookmark-manager/bookmarks.db
func getDefaultDatabasePath() (string, error) <span class="cov8" title="1">{
        var configDir string
        var err error

        switch runtime.GOOS </span>{
        case "windows":<span class="cov0" title="0">
                configDir = os.Getenv("APPDATA")
                if configDir == "" </span><span class="cov0" title="0">{
                        return "", fmt.Errorf("APPDATA environment variable not set")
                }</span>
        case "darwin":<span class="cov0" title="0">
                homeDir, err := os.UserHomeDir()
                if err != nil </span><span class="cov0" title="0">{
                        return "", fmt.Errorf("failed to get user home directory: %w", err)
                }</span>
                <span class="cov0" title="0">configDir = filepath.Join(homeDir, "Library", "Application Support")</span>
        default:<span class="cov8" title="1"> // Linux and other Unix-like systems
                configDir = os.Getenv("XDG_CONFIG_HOME")
                if configDir == "" </span><span class="cov8" title="1">{
                        homeDir, err := os.UserHomeDir()
                        if err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to get user home directory: %w", err)
                        }</span>
                        <span class="cov8" title="1">configDir = filepath.Join(homeDir, ".config")</span>
                }
        }

        <span class="cov8" title="1">appDir := filepath.Join(configDir, "bookmark-manager")
        dbPath := filepath.Join(appDir, "bookmarks.db")

        // Ensure the directory exists
        if err = os.MkdirAll(appDir, 0755); err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to create config directory %s: %w", appDir, err)
        }</span>

        <span class="cov8" title="1">return dbPath, nil</span>
}

// GetDatabasePath returns the configured database path
func (c *Config) GetDatabasePath() string <span class="cov8" title="1">{
        return c.DatabasePath
}</span>

// GetLogLevel returns the configured log level
func (c *Config) GetLogLevel() string <span class="cov8" title="1">{
        return c.LogLevel
}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">// Package database provides SQLite3 database connectivity and ORM functionality
// using GORM.
package database

import (
        "fmt"

        "github.com/jhoffmann/bookmark-manager/internal/config"
        "gorm.io/driver/sqlite"
        "gorm.io/gorm"
        "gorm.io/gorm/logger"
)

// DB represents the database interface
type DB interface {
        // Connection management
        Close() error
        Ping() error
        // Internal method for testing
        GetDB() *gorm.DB
}

// Database wraps the GORM database instance
type Database struct {
        db *gorm.DB
}

// NewDatabase creates a new database connection with the provided configuration
func NewDatabase(cfg *config.Config) (DB, error) <span class="cov8" title="1">{
        // Configure GORM logger level
        logLevel := logger.Warn
        switch cfg.GetLogLevel() </span>{
        case "info":<span class="cov8" title="1">
                logLevel = logger.Info</span>
        case "error":<span class="cov8" title="1">
                logLevel = logger.Error</span>
        case "silent":<span class="cov8" title="1">
                logLevel = logger.Silent</span>
        }

        <span class="cov8" title="1">db, err := gorm.Open(sqlite.Open(cfg.GetDatabasePath()), &amp;gorm.Config{
                Logger: logger.Default.LogMode(logLevel),
        })
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to connect to database: %w", err)
        }</span>

        <span class="cov8" title="1">database := &amp;Database{db: db}

        if err := database.migrate(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to migrate database: %w", err)
        }</span>

        <span class="cov8" title="1">return database, nil</span>
}

// migrate runs auto-migration for all models
func (d *Database) migrate() error <span class="cov8" title="1">{
        // Auto-migrate bookmark model
        if err := d.db.AutoMigrate(&amp;BookmarkModel{}); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to auto-migrate bookmark table: %w", err)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// BookmarkModel represents the bookmark table structure for migration
// This is a minimal model definition for auto-migration purposes
type BookmarkModel struct {
        ID          uint    `gorm:"primaryKey"`
        Folder      string  `gorm:"not null"`
        DateCreated string  `gorm:"type:datetime"`
        Category    string  `gorm:"type:varchar(50);default:'default'"`
        CreatedAt   string  `gorm:"type:datetime"`
        UpdatedAt   string  `gorm:"type:datetime"`
        DeletedAt   *string `gorm:"index;type:datetime"`
}

// TableName specifies the table name for the bookmark model
func (BookmarkModel) TableName() string <span class="cov8" title="1">{
        return "bookmarks"
}</span>

// Close closes the database connection
func (d *Database) Close() error <span class="cov8" title="1">{
        sqlDB, err := d.db.DB()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get underlying sql.DB: %w", err)
        }</span>

        <span class="cov8" title="1">if err := sqlDB.Close(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to close database connection: %w", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// Ping checks if the database connection is alive
func (d *Database) Ping() error <span class="cov8" title="1">{
        sqlDB, err := d.db.DB()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get underlying sql.DB: %w", err)
        }</span>

        <span class="cov8" title="1">if err := sqlDB.Ping(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to ping database: %w", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// GetDB returns the underlying GORM database instance (for testing)
func (d *Database) GetDB() *gorm.DB <span class="cov8" title="1">{
        return d.db
}</span>
</pre>
		
		<pre class="file" id="file7" style="display: none">// Package confirm provides a simple list-based confirmation for dangerous operations.
package confirm

import (
        "github.com/charmbracelet/bubbles/list"
        tea "github.com/charmbracelet/bubbletea"
        "github.com/charmbracelet/lipgloss"
        "github.com/jhoffmann/bookmark-manager/internal/bookmark"
)

var docStyle = lipgloss.NewStyle().Margin(1, 2)

// choiceItem implements list.Item for yes/no choices
type choiceItem struct {
        title       string
        description string
        value       bool
}

func (i choiceItem) FilterValue() string <span class="cov0" title="0">{ return i.title }</span>
func (i choiceItem) Title() string       <span class="cov0" title="0">{ return i.title }</span>
func (i choiceItem) Description() string <span class="cov0" title="0">{ return i.description }</span>

// Model represents the confirmation state
type Model struct {
        list     list.Model
        bookmark *bookmark.Bookmark
        visible  bool
        result   bool
        chosen   bool
}

// New creates a new confirmation model
func New() Model <span class="cov0" title="0">{
        items := []list.Item{
                choiceItem{title: "No", description: "Cancel - don't delete", value: false},
                choiceItem{title: "Yes", description: "Delete this bookmark", value: true},
        }

        delegate := list.NewDefaultDelegate()
        delegate.ShowDescription = true

        l := list.New(items, delegate, 0, 0) // Use same sizing as main list
        l.Title = "Delete Bookmark?"
        l.SetShowStatusBar(true) // Same as main list
        l.SetFilteringEnabled(false)

        return Model{
                list:    l,
                visible: false,
                chosen:  false,
        }
}</span>

// Show displays the confirmation with the given bookmark
func (m *Model) Show(bookmark *bookmark.Bookmark, message string) <span class="cov0" title="0">{
        m.bookmark = bookmark
        m.visible = true
        m.chosen = false
        m.result = false
        m.list.Select(0) // Default to "No"

        // Update title to include bookmark info
        if bookmark != nil </span><span class="cov0" title="0">{
                m.list.Title = "Delete: " + bookmark.Folder + "?"
        }</span>
}

// Hide hides the confirmation
func (m *Model) Hide() <span class="cov0" title="0">{
        m.visible = false
        m.bookmark = nil
        m.chosen = false
}</span>

// IsVisible returns whether the confirmation is currently visible
func (m Model) IsVisible() bool <span class="cov0" title="0">{
        return m.visible
}</span>

// Update handles input events for the confirmation
func (m Model) Update(msg tea.Msg) (Model, tea.Cmd) <span class="cov0" title="0">{
        if !m.visible </span><span class="cov0" title="0">{
                return m, nil
        }</span>

        <span class="cov0" title="0">switch msg := msg.(type) </span>{
        case tea.WindowSizeMsg:<span class="cov0" title="0">
                h, v := docStyle.GetFrameSize()
                m.list.SetSize(msg.Width-h, msg.Height-v-4)</span>

        case tea.KeyMsg:<span class="cov0" title="0">
                switch msg.String() </span>{
                case "enter":<span class="cov0" title="0">
                        // Get selected choice
                        if selectedItem, ok := m.list.SelectedItem().(choiceItem); ok </span><span class="cov0" title="0">{
                                m.result = selectedItem.value
                                m.chosen = true
                                m.visible = false
                                return m, nil
                        }</span>
                case "esc", "q", "n":<span class="cov0" title="0">
                        m.result = false
                        m.chosen = true
                        m.visible = false
                        return m, nil</span>
                case "y":<span class="cov0" title="0">
                        m.result = true
                        m.chosen = true
                        m.visible = false
                        return m, nil</span>
                }
        }

        <span class="cov0" title="0">var cmd tea.Cmd
        m.list, cmd = m.list.Update(msg)
        return m, cmd</span>
}

// View renders the confirmation
func (m Model) View() string <span class="cov0" title="0">{
        if !m.visible </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov0" title="0">return docStyle.Render(m.list.View())</span>
}

// Result represents the result of the confirmation
type Result struct {
        Confirmed bool
        Bookmark  *bookmark.Bookmark
}

// GetResult returns the result based on current state
func (m Model) GetResult() Result <span class="cov0" title="0">{
        return Result{
                Confirmed: m.result,
                Bookmark:  m.bookmark,
        }
}</span>

// HasResult returns whether the user has made a choice
func (m Model) HasResult() bool <span class="cov0" title="0">{
        return m.chosen
}</span>
</pre>
		
		<pre class="file" id="file8" style="display: none">// Package list provides the main TUI list interface for browsing bookmarks.
package list

import (
        "fmt"
        "os/exec"
        "runtime"
        "sort"
        "strings"

        "github.com/charmbracelet/bubbles/key"
        "github.com/charmbracelet/bubbles/list"
        "github.com/charmbracelet/bubbles/textinput"
        tea "github.com/charmbracelet/bubbletea"
        "github.com/charmbracelet/lipgloss"
        "github.com/jhoffmann/bookmark-manager/internal/bookmark"
        "github.com/jhoffmann/bookmark-manager/internal/tui/confirm"
        "github.com/jhoffmann/bookmark-manager/internal/tui/styles"
)

var docStyle = lipgloss.NewStyle().Margin(1, 2)

// Model represents the main TUI state for the bookmark list
type Model struct {
        list           list.Model
        categories     []string
        activeCategory string
        filter         textinput.Model
        filterFocused  bool
        bookmarks      []*bookmark.Bookmark
        allBookmarks   []*bookmark.Bookmark
        service        *bookmark.Service
        keys           keyMap
        confirmDialog  confirm.Model
        showingDialog  bool
        windowSize     tea.WindowSizeMsg
        err            error
}

// bookmarkItem implements list.Item for use with bubbles/list
type bookmarkItem struct {
        bookmark *bookmark.Bookmark
}

func (i bookmarkItem) FilterValue() string <span class="cov0" title="0">{
        return i.bookmark.Folder + " " + string(i.bookmark.Category)
}</span>

func (i bookmarkItem) Title() string <span class="cov0" title="0">{
        return i.bookmark.Folder
}</span>

func (i bookmarkItem) Description() string <span class="cov0" title="0">{
        return string(i.bookmark.Category)
}</span>

// keyMap defines key bindings for the list interface
type keyMap struct {
        NextTab     key.Binding
        PrevTab     key.Binding
        Delete      key.Binding
        Filter      key.Binding
        Open        key.Binding
        Quit        key.Binding
        ClearFilter key.Binding
        Enter       key.Binding
}

// DefaultKeyMap returns the default key bindings
func DefaultKeyMap() keyMap <span class="cov0" title="0">{
        return keyMap{
                NextTab: key.NewBinding(
                        key.WithKeys("tab"),
                        key.WithHelp("tab", "next category"),
                ),
                PrevTab: key.NewBinding(
                        key.WithKeys("shift+tab"),
                        key.WithHelp("shift+tab", "prev category"),
                ),
                Delete: key.NewBinding(
                        key.WithKeys("x", "d"),
                        key.WithHelp("x/d", "delete bookmark"),
                ),
                Filter: key.NewBinding(
                        key.WithKeys("/"),
                        key.WithHelp("/", "filter bookmarks"),
                ),
                Open: key.NewBinding(
                        key.WithKeys("o"),
                        key.WithHelp("o", "open folder"),
                ),
                Quit: key.NewBinding(
                        key.WithKeys("q", "esc", "ctrl+c"),
                        key.WithHelp("q", "quit"),
                ),
                ClearFilter: key.NewBinding(
                        key.WithKeys("ctrl+u"),
                        key.WithHelp("ctrl+u", "clear filter"),
                ),
                Enter: key.NewBinding(
                        key.WithKeys("enter"),
                        key.WithHelp("enter", "open folder"),
                ),
        }
}</span>

// New creates a new list model
func New(service *bookmark.Service, initialCategory string) Model <span class="cov0" title="0">{
        // Initialize text input for filtering
        filterInput := textinput.New()
        filterInput.Placeholder = "Type to filter bookmarks..."
        filterInput.CharLimit = 156

        // Initialize list
        items := []list.Item{}
        delegate := list.NewDefaultDelegate()

        l := list.New(items, delegate, 0, 0)
        l.Title = "All" // Start with "All" category
        l.SetShowStatusBar(true)
        l.SetFilteringEnabled(false) // We handle filtering ourselves

        return Model{
                list:           l,
                categories:     []string{"All"},
                activeCategory: initialCategory,
                filter:         filterInput,
                filterFocused:  false,
                keys:           DefaultKeyMap(),
                confirmDialog:  confirm.New(),
                service:        service,
        }
}</span>

// Init initializes the model (required by tea.Model interface)
func (m Model) Init() tea.Cmd <span class="cov0" title="0">{
        return m.LoadBookmarks()
}</span>

// LoadBookmarks loads bookmarks from the database
func (m *Model) LoadBookmarks() tea.Cmd <span class="cov0" title="0">{
        return func() tea.Msg </span><span class="cov0" title="0">{
                // Load all bookmarks
                allBookmarks, err := bookmark.List(m.service, 0, 0)
                if err != nil </span><span class="cov0" title="0">{
                        return errMsg{err}
                }</span>

                // Extract unique categories
                <span class="cov0" title="0">categorySet := make(map[string]bool)
                categorySet["All"] = true
                categorySet["default"] = true

                for _, b := range allBookmarks </span><span class="cov0" title="0">{
                        categorySet[string(b.Category)] = true
                }</span>

                <span class="cov0" title="0">categories := make([]string, 0, len(categorySet))
                categories = append(categories, "All")
                for cat := range categorySet </span><span class="cov0" title="0">{
                        if cat != "All" </span><span class="cov0" title="0">{
                                categories = append(categories, cat)
                        }</span>
                }
                <span class="cov0" title="0">sort.Strings(categories[1:]) // Sort all except "All"

                return bookmarksLoadedMsg{
                        bookmarks:  allBookmarks,
                        categories: categories,
                }</span>
        }
}

// Update handles input events
func (m Model) Update(msg tea.Msg) (tea.Model, tea.Cmd) <span class="cov0" title="0">{
        var cmd tea.Cmd
        var cmds []tea.Cmd

        // Handle confirmation dialog first
        if m.showingDialog </span><span class="cov0" title="0">{
                newConfirm, confirmCmd := m.confirmDialog.Update(msg)
                m.confirmDialog = newConfirm

                // Check if user made a choice
                if m.confirmDialog.HasResult() </span><span class="cov0" title="0">{
                        m.showingDialog = false
                        result := m.confirmDialog.GetResult()
                        if result.Confirmed &amp;&amp; result.Bookmark != nil </span><span class="cov0" title="0">{
                                return m, m.deleteBookmark(result.Bookmark)
                        }</span>
                }

                <span class="cov0" title="0">return m, confirmCmd</span>
        }

        <span class="cov0" title="0">switch msg := msg.(type) </span>{
        case tea.WindowSizeMsg:<span class="cov0" title="0">
                m.windowSize = msg // Store the current window size
                h, v := docStyle.GetFrameSize()
                m.list.SetSize(msg.Width-h, msg.Height-v-4) // Reserve space for filter
                m.filter.Width = msg.Width - h - 10</span>

        case tea.KeyMsg:<span class="cov0" title="0">
                // Handle filter input when focused
                if m.filterFocused </span><span class="cov0" title="0">{
                        switch msg.String() </span>{
                        case "esc":<span class="cov0" title="0">
                                m.filterFocused = false
                                m.filter.Blur()</span>
                        case "enter":<span class="cov0" title="0">
                                m.filterFocused = false
                                m.filter.Blur()
                                return m, m.applyFilter()</span>
                        default:<span class="cov0" title="0">
                                m.filter, cmd = m.filter.Update(msg)
                                cmds = append(cmds, cmd)
                                // Auto-apply filter as user types
                                cmds = append(cmds, m.applyFilter())</span>
                        }
                        <span class="cov0" title="0">return m, tea.Batch(cmds...)</span>
                }

                // Handle main interface key bindings
                <span class="cov0" title="0">switch </span>{
                case key.Matches(msg, m.keys.Quit):<span class="cov0" title="0">
                        return m, tea.Quit</span>

                case key.Matches(msg, m.keys.Filter):<span class="cov0" title="0">
                        m.filterFocused = true
                        m.filter.Focus()</span>

                case key.Matches(msg, m.keys.ClearFilter):<span class="cov0" title="0">
                        m.filter.SetValue("")
                        return m, m.applyFilter()</span>

                case key.Matches(msg, m.keys.NextTab):<span class="cov0" title="0">
                        return m, m.nextCategory()</span>

                case key.Matches(msg, m.keys.PrevTab):<span class="cov0" title="0">
                        return m, m.prevCategory()</span>

                case key.Matches(msg, m.keys.Delete):<span class="cov0" title="0">
                        if selectedItem, ok := m.list.SelectedItem().(bookmarkItem); ok </span><span class="cov0" title="0">{
                                m.confirmDialog.Show(
                                        selectedItem.bookmark,
                                        "", // No longer needed with new simple dialog
                                )
                                m.showingDialog = true
                                // Immediately send the current window size to the confirm dialog
                                if m.windowSize.Width &gt; 0 &amp;&amp; m.windowSize.Height &gt; 0 </span><span class="cov0" title="0">{
                                        m.confirmDialog, _ = m.confirmDialog.Update(m.windowSize)
                                }</span>
                        }

                case key.Matches(msg, m.keys.Open, m.keys.Enter):<span class="cov0" title="0">
                        if selectedItem, ok := m.list.SelectedItem().(bookmarkItem); ok </span><span class="cov0" title="0">{
                                return m, m.openFolder(selectedItem.bookmark.Folder)
                        }</span>
                }

        case bookmarksLoadedMsg:<span class="cov0" title="0">
                m.allBookmarks = msg.bookmarks
                m.categories = msg.categories

                // Set initial category if not already set
                if m.activeCategory == "" </span><span class="cov0" title="0">{
                        m.activeCategory = "All"
                }</span>

                // Update list title to show current category
                <span class="cov0" title="0">m.list.Title = m.activeCategory

                return m, m.filterByCategory()</span>

        case bookmarksFilteredMsg:<span class="cov0" title="0">
                m.bookmarks = msg.bookmarks

                // Convert to list items
                items := make([]list.Item, len(m.bookmarks))
                for i, b := range m.bookmarks </span><span class="cov0" title="0">{
                        items[i] = bookmarkItem{bookmark: b}
                }</span>

                <span class="cov0" title="0">m.list.SetItems(items)</span>

        case bookmarkDeletedMsg:<span class="cov0" title="0">
                return m, m.LoadBookmarks()</span> // Reload bookmarks

        case errMsg:<span class="cov0" title="0">
                m.err = msg.err</span>
        }

        // Update list
        <span class="cov0" title="0">m.list, cmd = m.list.Update(msg)
        cmds = append(cmds, cmd)

        return m, tea.Batch(cmds...)</span>
}

// View renders the interface
func (m Model) View() string <span class="cov0" title="0">{
        if m.showingDialog </span><span class="cov0" title="0">{
                return m.confirmDialog.View()
        }</span>

        // Render filter if focused or has value
        <span class="cov0" title="0">var filterView string
        if m.filterFocused </span><span class="cov0" title="0">{
                filterStyle := styles.FocusedFilterInput
                filterView = filterStyle.Render("Filter: "+m.filter.View()) + "\n"
        }</span> else<span class="cov0" title="0"> if m.filter.Value() != "" </span><span class="cov0" title="0">{
                filterStyle := styles.FilterInput
                filterView = filterStyle.Render("Filter: "+m.filter.View()) + "\n"
        }</span>

        <span class="cov0" title="0">return docStyle.Render(filterView + m.list.View())</span>
}

// Helper functions

func (m *Model) nextCategory() tea.Cmd <span class="cov0" title="0">{
        for i, cat := range m.categories </span><span class="cov0" title="0">{
                if cat == m.activeCategory </span><span class="cov0" title="0">{
                        nextIndex := (i + 1) % len(m.categories)
                        m.activeCategory = m.categories[nextIndex]
                        m.list.Title = m.activeCategory // Update list title
                        break</span>
                }
        }
        <span class="cov0" title="0">return m.filterByCategory()</span>
}

func (m *Model) prevCategory() tea.Cmd <span class="cov0" title="0">{
        for i, cat := range m.categories </span><span class="cov0" title="0">{
                if cat == m.activeCategory </span><span class="cov0" title="0">{
                        prevIndex := (i - 1 + len(m.categories)) % len(m.categories)
                        m.activeCategory = m.categories[prevIndex]
                        m.list.Title = m.activeCategory // Update list title
                        break</span>
                }
        }
        <span class="cov0" title="0">return m.filterByCategory()</span>
}

func (m *Model) filterByCategory() tea.Cmd <span class="cov0" title="0">{
        return func() tea.Msg </span><span class="cov0" title="0">{
                var filtered []*bookmark.Bookmark

                if m.activeCategory == "All" </span><span class="cov0" title="0">{
                        filtered = m.allBookmarks
                }</span> else<span class="cov0" title="0"> {
                        for _, b := range m.allBookmarks </span><span class="cov0" title="0">{
                                if string(b.Category) == m.activeCategory </span><span class="cov0" title="0">{
                                        filtered = append(filtered, b)
                                }</span>
                        }
                }

                <span class="cov0" title="0">return bookmarksFilteredMsg{bookmarks: filtered}</span>
        }
}

func (m *Model) applyFilter() tea.Cmd <span class="cov0" title="0">{
        return func() tea.Msg </span><span class="cov0" title="0">{
                filterText := strings.ToLower(strings.TrimSpace(m.filter.Value()))

                var filtered []*bookmark.Bookmark
                source := m.allBookmarks

                // First filter by category
                if m.activeCategory != "All" </span><span class="cov0" title="0">{
                        source = []*bookmark.Bookmark{}
                        for _, b := range m.allBookmarks </span><span class="cov0" title="0">{
                                if string(b.Category) == m.activeCategory </span><span class="cov0" title="0">{
                                        source = append(source, b)
                                }</span>
                        }
                }

                // Then apply text filter
                <span class="cov0" title="0">if filterText == "" </span><span class="cov0" title="0">{
                        filtered = source
                }</span> else<span class="cov0" title="0"> {
                        for _, b := range source </span><span class="cov0" title="0">{
                                if strings.Contains(strings.ToLower(b.Folder), filterText) ||
                                        strings.Contains(strings.ToLower(string(b.Category)), filterText) </span><span class="cov0" title="0">{
                                        filtered = append(filtered, b)
                                }</span>
                        }
                }

                <span class="cov0" title="0">return bookmarksFilteredMsg{bookmarks: filtered}</span>
        }
}

func (m *Model) deleteBookmark(b *bookmark.Bookmark) tea.Cmd <span class="cov0" title="0">{
        return func() tea.Msg </span><span class="cov0" title="0">{
                if err := b.Delete(m.service); err != nil </span><span class="cov0" title="0">{
                        return errMsg{err}
                }</span>
                <span class="cov0" title="0">return bookmarkDeletedMsg{}</span>
        }
}

func (m *Model) openFolder(path string) tea.Cmd <span class="cov0" title="0">{
        return func() tea.Msg </span><span class="cov0" title="0">{
                var cmd *exec.Cmd

                switch runtime.GOOS </span>{
                case "darwin":<span class="cov0" title="0">
                        cmd = exec.Command("open", path)</span>
                case "windows":<span class="cov0" title="0">
                        cmd = exec.Command("explorer", path)</span>
                default:<span class="cov0" title="0"> // linux and others
                        cmd = exec.Command("xdg-open", path)</span>
                }

                <span class="cov0" title="0">if err := cmd.Run(); err != nil </span><span class="cov0" title="0">{
                        return errMsg{fmt.Errorf("failed to open folder: %w", err)}
                }</span>

                <span class="cov0" title="0">return nil</span>
        }
}

// Messages
type bookmarksLoadedMsg struct {
        bookmarks  []*bookmark.Bookmark
        categories []string
}

type bookmarksFilteredMsg struct {
        bookmarks []*bookmark.Bookmark
}

type bookmarkDeletedMsg struct{}

type errMsg struct {
        err error
}
</pre>
		
		<pre class="file" id="file9" style="display: none">// Package styles provides consistent styling for the TUI using lipgloss.
package styles

import (
        "github.com/charmbracelet/lipgloss"
)

// Color palette for the bookmark manager TUI
var (
        Primary   = lipgloss.Color("63")  // Purple
        Secondary = lipgloss.Color("39")  // Light blue
        Success   = lipgloss.Color("42")  // Green
        Warning   = lipgloss.Color("214") // Orange
        Error     = lipgloss.Color("196") // Red
        Muted     = lipgloss.Color("245") // Gray
        Subtle    = lipgloss.Color("241") // Dark gray
        Border    = lipgloss.Color("238") // Border gray
)

// Base styles
var (
        // BaseStyle is the foundation for all components
        BaseStyle = lipgloss.NewStyle().
                        Padding(0, 1)

        // BorderStyle for containers
        BorderStyle = lipgloss.NewStyle().
                        Border(lipgloss.RoundedBorder()).
                        BorderForeground(Border).
                        Padding(1, 2)

        // FocusedBorderStyle for focused containers
        FocusedBorderStyle = BorderStyle.Copy().
                                BorderForeground(Primary)
)

// Tab styles
var (
        // ActiveTab style for the currently selected tab
        ActiveTab = lipgloss.NewStyle().
                        Bold(true).
                        Foreground(lipgloss.Color("15")).
                        Background(Primary).
                        Padding(0, 2).
                        MarginRight(1)

        // InactiveTab style for non-selected tabs
        InactiveTab = lipgloss.NewStyle().
                        Foreground(Muted).
                        Background(lipgloss.Color("236")).
                        Padding(0, 2).
                        MarginRight(1)

        // TabContainer style for the tab bar
        TabContainer = lipgloss.NewStyle().
                        BorderBottom(true).
                        BorderStyle(lipgloss.NormalBorder()).
                        BorderBottomForeground(Border).
                        MarginBottom(1)
)

// List styles
var (
        // SelectedItem style for the currently highlighted list item
        SelectedItem = lipgloss.NewStyle().
                        Foreground(lipgloss.Color("15")).
                        Background(Primary).
                        Bold(true).
                        Padding(0, 1)

        // UnselectedItem style for non-highlighted list items
        UnselectedItem = lipgloss.NewStyle().
                        Foreground(lipgloss.Color("15")).
                        Padding(0, 1)

        // ItemPath style for the folder path in list items
        ItemPath = lipgloss.NewStyle().
                        Foreground(lipgloss.Color("15")).
                        Width(50)

        // ItemCategory style for the category badge in list items
        ItemCategory = lipgloss.NewStyle().
                        Foreground(lipgloss.Color("15")).
                        Background(Secondary).
                        Padding(0, 1).
                        MarginLeft(2).
                        Bold(true)

        // ListContainer style for the list wrapper
        ListContainer = lipgloss.NewStyle().
                        Border(lipgloss.RoundedBorder()).
                        BorderForeground(Border).
                        Height(20).
                        Padding(1)
)

// Input styles
var (
        // FilterInput style for the search filter
        FilterInput = lipgloss.NewStyle().
                        Border(lipgloss.RoundedBorder()).
                        BorderForeground(Muted).
                        Padding(0, 1).
                        MarginBottom(1)

        // FocusedFilterInput style when filter is focused
        FocusedFilterInput = FilterInput.Copy().
                                BorderForeground(Primary)
)

// Status styles
var (
        // StatusBar style for the bottom status line
        StatusBar = lipgloss.NewStyle().
                        Foreground(Muted).
                        BorderTop(true).
                        BorderStyle(lipgloss.NormalBorder()).
                        BorderTopForeground(Border).
                        MarginTop(1).
                        Padding(1, 2)

        // HelpText style for help information
        HelpText = lipgloss.NewStyle().
                        Foreground(Subtle)

        // CountText style for showing bookmark counts
        CountText = lipgloss.NewStyle().
                        Foreground(Secondary).
                        Bold(true)
)

// Dialog styles
var (
        // DialogBox style for confirmation dialogs
        DialogBox = lipgloss.NewStyle().
                        Border(lipgloss.RoundedBorder()).
                        BorderForeground(Primary).
                        Padding(2, 4).
                        Background(lipgloss.Color("235")).
                        Width(50).
                        Align(lipgloss.Center)

        // DialogTitle style for dialog titles
        DialogTitle = lipgloss.NewStyle().
                        Foreground(Primary).
                        Bold(true).
                        Align(lipgloss.Center).
                        MarginBottom(2)

        // DialogText style for dialog content
        DialogText = lipgloss.NewStyle().
                        Foreground(lipgloss.Color("15")).
                        Align(lipgloss.Center).
                        MarginBottom(1)

        // ConfirmButton style for confirmation buttons
        ConfirmButton = lipgloss.NewStyle().
                        Foreground(lipgloss.Color("15")).
                        Background(Error).
                        Padding(0, 3).
                        Bold(true).
                        Border(lipgloss.RoundedBorder())

        // CancelButton style for cancel buttons
        CancelButton = lipgloss.NewStyle().
                        Foreground(lipgloss.Color("15")).
                        Background(Muted).
                        Padding(0, 3).
                        Bold(true).
                        Border(lipgloss.RoundedBorder())
)

// Success/Error message styles
var (
        // SuccessMessage style for success notifications
        SuccessMessage = lipgloss.NewStyle().
                        Foreground(Success).
                        Bold(true).
                        Padding(0, 1)

        // ErrorMessage style for error notifications
        ErrorMessage = lipgloss.NewStyle().
                        Foreground(Error).
                        Bold(true).
                        Padding(0, 1)

        // WarningMessage style for warning notifications
        WarningMessage = lipgloss.NewStyle().
                        Foreground(Warning).
                        Bold(true).
                        Padding(0, 1)
)

// Utility functions for dynamic styling

// GetCategoryStyle returns a style for category badges with different colors
func GetCategoryStyle(category string) lipgloss.Style <span class="cov0" title="0">{
        switch category </span>{
        case "work":<span class="cov0" title="0">
                return ItemCategory.Copy().Background(lipgloss.Color("208"))</span> // Orange
        case "personal":<span class="cov0" title="0">
                return ItemCategory.Copy().Background(lipgloss.Color("35"))</span> // Green
        case "default":<span class="cov0" title="0">
                return ItemCategory.Copy().Background(Muted)</span>
        default:<span class="cov0" title="0">
                return ItemCategory.Copy().Background(Secondary)</span>
        }
}

// Center centers text within a given width
func Center(text string, width int) string <span class="cov0" title="0">{
        return lipgloss.NewStyle().
                Width(width).
                Align(lipgloss.Center).
                Render(text)
}</span>

// Truncate truncates text to fit within a given width with ellipsis
func Truncate(text string, width int) string <span class="cov0" title="0">{
        if lipgloss.Width(text) &lt;= width </span><span class="cov0" title="0">{
                return text
        }</span>
        <span class="cov0" title="0">if width &lt; 3 </span><span class="cov0" title="0">{
                return text[:width]
        }</span>
        <span class="cov0" title="0">return text[:width-3] + "..."</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package main

import (
        "fmt"
        "os"

        "github.com/jhoffmann/bookmark-manager/cmd"
        "github.com/spf13/cobra"
)

func main() <span class="cov0" title="0">{
        var rootCmd = &amp;cobra.Command{
                Use:   "bookmark-manager",
                Short: "A beautiful TUI bookmark manager for folders",
                Long: `Bookmark Manager - A command-line tool for managing folder bookmarks with a beautiful terminal interface.

Use this tool to:
- Add folder bookmarks with custom categories
- Browse bookmarks with an interactive TUI
- Filter and search through your bookmarks
- Export bookmarks to JSON

Run without arguments to see this help, or use one of the subcommands.`,
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov0" title="0">{
                        // Default to help when no subcommands
                        cmd.Help()
                }</span>,
        }

        // Add subcommands
        <span class="cov0" title="0">rootCmd.AddCommand(cmd.GetAddCmd())
        rootCmd.AddCommand(cmd.GetListCmd())
        rootCmd.AddCommand(cmd.GetExportCmd())

        // Execute root command
        if err := rootCmd.Execute(); err != nil </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "Error: %v\n", err)
                os.Exit(1)
        }</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
